// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package dbLayer

import (
	"context"
	"database/sql"
)

const createNewBook = `-- name: CreateNewBook :exec
INSERT INTO books (
  title, author, year, genre, isbn, rating, readers, quantity
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateNewBookParams struct {
	Title    string
	Author   string
	Year     int64
	Genre    string
	Isbn     string
	Rating   float64
	Readers  int64
	Quantity int64
}

func (q *Queries) CreateNewBook(ctx context.Context, arg CreateNewBookParams) error {
	_, err := q.db.ExecContext(ctx, createNewBook,
		arg.Title,
		arg.Author,
		arg.Year,
		arg.Genre,
		arg.Isbn,
		arg.Rating,
		arg.Readers,
		arg.Quantity,
	)
	return err
}

const createNewUser = `-- name: CreateNewUser :exec
INSERT INTO users (
  uname, passwd_hash, email, first_name, last_name, user_type
) VALUES (
  ?, ?, ?, ?, ?, ?
)
`

type CreateNewUserParams struct {
	Uname      string
	PasswdHash string
	Email      string
	FirstName  string
	LastName   string
	UserType   string
}

func (q *Queries) CreateNewUser(ctx context.Context, arg CreateNewUserParams) error {
	_, err := q.db.ExecContext(ctx, createNewUser,
		arg.Uname,
		arg.PasswdHash,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.UserType,
	)
	return err
}

const createReservationForBook = `-- name: CreateReservationForBook :exec
INSERT INTO reservations (
	uname, title
) VALUES (
	?, ?
)
`

type CreateReservationForBookParams struct {
	Uname string
	Title string
}

func (q *Queries) CreateReservationForBook(ctx context.Context, arg CreateReservationForBookParams) error {
	_, err := q.db.ExecContext(ctx, createReservationForBook, arg.Uname, arg.Title)
	return err
}

const createTableBooks = `-- name: CreateTableBooks :exec
CREATE TABLE books (
		book_id INTEGER PRIMARY KEY AUTOINCREMENT,
		title TEXT UNIQUE NOT NULL,
		author TEXT NOT NULL,
		year INTEGER NOT NULL,
		genre TEXT NOT NULL,
		isbn TEXT NOT NULL,
		rating REAL DEFAULT '0' NOT NULL,
		readers INTEGER DEFAULT '0' NOT NULL,
		quantity INTEGER DEFAULT '1' NOT NULL,
		sqltime TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
		validity TEXT DEFAULT 'valid' NOT NULL
)
`

func (q *Queries) CreateTableBooks(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTableBooks)
	return err
}

const createTableReservation = `-- name: CreateTableReservation :exec
CREATE TABLE reservations (
		reservation_id INTEGER PRIMARY KEY AUTOINCREMENT,
		uname TEXT NOT NULL,
		title TEXT NOT NULL,
		sqltime TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
		validity TEXT DEFAULT 'valid' NOT NULL
)
`

func (q *Queries) CreateTableReservation(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTableReservation)
	return err
}

const createTableTransactions = `-- name: CreateTableTransactions :exec
CREATE TABLE transactions (
		transaction_id INTEGER PRIMARY KEY AUTOINCREMENT,
		uname TEXT NOT NULL,
		title TEXT NOT NULL,
		transaction_type TEXT NOT NULL,
		sqltime TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
		validity TEXT DEFAULT 'valid' NOT NULL
)
`

func (q *Queries) CreateTableTransactions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTableTransactions)
	return err
}

const createTableUsers = `-- name: CreateTableUsers :exec
CREATE TABLE users (
		user_id INTEGER PRIMARY KEY AUTOINCREMENT,
		uname TEXT UNIQUE NOT NULL,
		passwd_hash TEXT NOT NULL,
		email TEXT NOT NULL,
		first_name TEXT NOT NULL,
		last_name TEXT NOT NULL,
		user_type TEXT NOT NULL,
		actions_left INTEGER DEFAULT '5' NOT NULL,
		sqltime TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
		validity TEXT DEFAULT 'valid' NOT NULL
)
`

func (q *Queries) CreateTableUsers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createTableUsers)
	return err
}

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (
	uname, title, transaction_type
) VALUES (
	?, ?, ?
)
`

type CreateTransactionParams struct {
	Uname           string
	Title           string
	TransactionType string
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createTransaction, arg.Uname, arg.Title, arg.TransactionType)
	return err
}

const invalidateUser = `-- name: InvalidateUser :exec
UPDATE users
SET validity = 'invalid'
WHERE uname = ?
`

func (q *Queries) InvalidateUser(ctx context.Context, uname string) error {
	_, err := q.db.ExecContext(ctx, invalidateUser, uname)
	return err
}

const retrieveAllBooks = `-- name: RetrieveAllBooks :many
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books
`

func (q *Queries) RetrieveAllBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, retrieveAllBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.Genre,
			&i.Isbn,
			&i.Rating,
			&i.Readers,
			&i.Quantity,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveAvailibleBooks = `-- name: RetrieveAvailibleBooks :many
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books
WHERE quantity > 0 AND validity = 'valid' AND title LIKE '%'|| ? || '%'
`

func (q *Queries) RetrieveAvailibleBooks(ctx context.Context, dollar_1 sql.NullString) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, retrieveAvailibleBooks, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.Genre,
			&i.Isbn,
			&i.Rating,
			&i.Readers,
			&i.Quantity,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveBookByBID = `-- name: RetrieveBookByBID :one
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books
WHERE book_id = ?
`

func (q *Queries) RetrieveBookByBID(ctx context.Context, bookID int64) (Book, error) {
	row := q.db.QueryRowContext(ctx, retrieveBookByBID, bookID)
	var i Book
	err := row.Scan(
		&i.BookID,
		&i.Title,
		&i.Author,
		&i.Year,
		&i.Genre,
		&i.Isbn,
		&i.Rating,
		&i.Readers,
		&i.Quantity,
		&i.Sqltime,
		&i.Validity,
	)
	return i, err
}

const retrieveBookFromBID = `-- name: RetrieveBookFromBID :one
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books
WHERE book_id = ?
`

func (q *Queries) RetrieveBookFromBID(ctx context.Context, bookID int64) (Book, error) {
	row := q.db.QueryRowContext(ctx, retrieveBookFromBID, bookID)
	var i Book
	err := row.Scan(
		&i.BookID,
		&i.Title,
		&i.Author,
		&i.Year,
		&i.Genre,
		&i.Isbn,
		&i.Rating,
		&i.Readers,
		&i.Quantity,
		&i.Sqltime,
		&i.Validity,
	)
	return i, err
}

const retrieveBooksByAuthorValue = `-- name: RetrieveBooksByAuthorValue :many
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books
WHERE author LIKE '%'|| ? ||'%'
`

func (q *Queries) RetrieveBooksByAuthorValue(ctx context.Context, dollar_1 sql.NullString) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, retrieveBooksByAuthorValue, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.Genre,
			&i.Isbn,
			&i.Rating,
			&i.Readers,
			&i.Quantity,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveBooksByISBN = `-- name: RetrieveBooksByISBN :many
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books
WHERE isbn = ?
`

func (q *Queries) RetrieveBooksByISBN(ctx context.Context, isbn string) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, retrieveBooksByISBN, isbn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.Genre,
			&i.Isbn,
			&i.Rating,
			&i.Readers,
			&i.Quantity,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveBooksByPopularity = `-- name: RetrieveBooksByPopularity :many
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books 
ORDER BY readers DESC
`

func (q *Queries) RetrieveBooksByPopularity(ctx context.Context) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, retrieveBooksByPopularity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.Genre,
			&i.Isbn,
			&i.Rating,
			&i.Readers,
			&i.Quantity,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveBooksByRating = `-- name: RetrieveBooksByRating :many
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books
ORDER BY rating DESC
`

func (q *Queries) RetrieveBooksByRating(ctx context.Context) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, retrieveBooksByRating)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.Genre,
			&i.Isbn,
			&i.Rating,
			&i.Readers,
			&i.Quantity,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveBooksByTitleValue = `-- name: RetrieveBooksByTitleValue :many
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books
WHERE title LIKE '%'|| ? ||'%'
`

func (q *Queries) RetrieveBooksByTitleValue(ctx context.Context, dollar_1 sql.NullString) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, retrieveBooksByTitleValue, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.Genre,
			&i.Isbn,
			&i.Rating,
			&i.Readers,
			&i.Quantity,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveBooksOfGenre = `-- name: RetrieveBooksOfGenre :many
SELECT book_id, title, author, year, genre, isbn, rating, readers, quantity, sqltime, validity FROM books
WHERE genre = ?
ORDER BY rating DESC
`

func (q *Queries) RetrieveBooksOfGenre(ctx context.Context, genre string) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, retrieveBooksOfGenre, genre)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.Genre,
			&i.Isbn,
			&i.Rating,
			&i.Readers,
			&i.Quantity,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveLibrarian = `-- name: RetrieveLibrarian :one
SELECT user_id, uname, passwd_hash, email, first_name, last_name, user_type, actions_left, sqltime, validity FROM users
WHERE uname = ? and user_type='librarian'
`

func (q *Queries) RetrieveLibrarian(ctx context.Context, uname string) (User, error) {
	row := q.db.QueryRowContext(ctx, retrieveLibrarian, uname)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Uname,
		&i.PasswdHash,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.UserType,
		&i.ActionsLeft,
		&i.Sqltime,
		&i.Validity,
	)
	return i, err
}

const retrieveMembersToRevokeLike = `-- name: RetrieveMembersToRevokeLike :many
SELECT user_id, uname, passwd_hash, email, first_name, last_name, user_type, actions_left, sqltime, validity FROM users
WHERE validity='valid' and user_type='member' AND uname LIKE '%'|| ? || '%'
`

func (q *Queries) RetrieveMembersToRevokeLike(ctx context.Context, dollar_1 sql.NullString) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, retrieveMembersToRevokeLike, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Uname,
			&i.PasswdHash,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.UserType,
			&i.ActionsLeft,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrievePsswdHash = `-- name: RetrievePsswdHash :one
SELECT passwd_hash FROM users
WHERE uname = ? AND validity = 'valid' AND user_type != 'approvalreq'
`

func (q *Queries) RetrievePsswdHash(ctx context.Context, uname string) (string, error) {
	row := q.db.QueryRowContext(ctx, retrievePsswdHash, uname)
	var passwd_hash string
	err := row.Scan(&passwd_hash)
	return passwd_hash, err
}

const retrieveReservedBooks = `-- name: RetrieveReservedBooks :many
SELECT reservation_id, reservations.title, author, rating, book_id
FROM reservations,books
WHERE reservations.uname = ? 
AND reservations.validity = 'valid' 
AND reservations.title = books.title
`

type RetrieveReservedBooksRow struct {
	ReservationID int64
	Title         string
	Author        string
	Rating        float64
	BookID        int64
}

func (q *Queries) RetrieveReservedBooks(ctx context.Context, uname string) ([]RetrieveReservedBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, retrieveReservedBooks, uname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RetrieveReservedBooksRow
	for rows.Next() {
		var i RetrieveReservedBooksRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.Title,
			&i.Author,
			&i.Rating,
			&i.BookID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveReturnableBooksOfUser = `-- name: RetrieveReturnableBooksOfUser :many
SELECT transaction_id, uname, title, transaction_type, sqltime, validity FROM transactions
WHERE validity = 'valid' AND transaction_type = 'issue' AND uname = ?
`

func (q *Queries) RetrieveReturnableBooksOfUser(ctx context.Context, uname string) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, retrieveReturnableBooksOfUser, uname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.Uname,
			&i.Title,
			&i.TransactionType,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveUserByUName = `-- name: RetrieveUserByUName :one
SELECT user_id, uname, passwd_hash, email, first_name, last_name, user_type, actions_left, sqltime, validity FROM users
WHERE uname = ? AND validity = 'valid'
`

func (q *Queries) RetrieveUserByUName(ctx context.Context, uname string) (User, error) {
	row := q.db.QueryRowContext(ctx, retrieveUserByUName, uname)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Uname,
		&i.PasswdHash,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.UserType,
		&i.ActionsLeft,
		&i.Sqltime,
		&i.Validity,
	)
	return i, err
}

const retrieveUsersByUType = `-- name: RetrieveUsersByUType :many
SELECT user_id, uname, passwd_hash, email, first_name, last_name, user_type, actions_left, sqltime, validity FROM users
WHERE user_type = ? AND validity = 'valid'
`

func (q *Queries) RetrieveUsersByUType(ctx context.Context, userType string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, retrieveUsersByUType, userType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Uname,
			&i.PasswdHash,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.UserType,
			&i.ActionsLeft,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveUsersThatReqApprovalLike = `-- name: RetrieveUsersThatReqApprovalLike :many
SELECT user_id, uname, passwd_hash, email, first_name, last_name, user_type, actions_left, sqltime, validity FROM users
WHERE validity='valid' and user_type='approvalreq' AND uname LIKE '%'|| ? || '%'
`

func (q *Queries) RetrieveUsersThatReqApprovalLike(ctx context.Context, dollar_1 sql.NullString) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, retrieveUsersThatReqApprovalLike, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Uname,
			&i.PasswdHash,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.UserType,
			&i.ActionsLeft,
			&i.Sqltime,
			&i.Validity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookQuantityDecrease = `-- name: UpdateBookQuantityDecrease :exec
UPDATE books
SET quantity = quantity - 1
WHERE book_id = ?
`

func (q *Queries) UpdateBookQuantityDecrease(ctx context.Context, bookID int64) error {
	_, err := q.db.ExecContext(ctx, updateBookQuantityDecrease, bookID)
	return err
}

const updateBookQuantityIncrease = `-- name: UpdateBookQuantityIncrease :exec
UPDATE books
SET quantity = quantity + 1
WHERE title = ?
`

func (q *Queries) UpdateBookQuantityIncrease(ctx context.Context, title string) error {
	_, err := q.db.ExecContext(ctx, updateBookQuantityIncrease, title)
	return err
}

const updateReservationValidity = `-- name: UpdateReservationValidity :exec
;

UPDATE reservations
SET validity = 'invalid'
WHERE reservation_id = ?
`

func (q *Queries) UpdateReservationValidity(ctx context.Context, reservationID int64) error {
	_, err := q.db.ExecContext(ctx, updateReservationValidity, reservationID)
	return err
}

const updateTransactionValidity = `-- name: UpdateTransactionValidity :exec
UPDATE transactions
SET validity = 'invalid'
WHERE transaction_id = ?
`

func (q *Queries) UpdateTransactionValidity(ctx context.Context, transactionID int64) error {
	_, err := q.db.ExecContext(ctx, updateTransactionValidity, transactionID)
	return err
}

const updateUserType = `-- name: UpdateUserType :exec
UPDATE users
SET user_type = ?
WHERE user_id = ? AND validity = 'valid'
`

type UpdateUserTypeParams struct {
	UserType string
	UserID   int64
}

func (q *Queries) UpdateUserType(ctx context.Context, arg UpdateUserTypeParams) error {
	_, err := q.db.ExecContext(ctx, updateUserType, arg.UserType, arg.UserID)
	return err
}

const updateUserValidity = `-- name: UpdateUserValidity :exec
UPDATE users
SET validity = 'invalid'
WHERE user_id = ?
`

func (q *Queries) UpdateUserValidity(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, updateUserValidity, userID)
	return err
}
